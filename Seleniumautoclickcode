
# tableau_views_owners_autoscroll_enhanced.py
# Enhanced scraper for Tableau Explore ▸ All Views with improved pagination handling and view owner extraction

import time
import pandas as pd
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait, Select
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.action_chains import ActionChains
from webdriver_manager.chrome import ChromeDriverManager
from selenium.webdriver.chrome.service import Service as ChromeService

# ==================== EDIT THESE ====================
SERVER   = "https://mytableau.cvs.com"   # no trailing '/#/'
SITE_ID  = "RX_OPS"                      # must match /site/<value>/ in URLs
OUTPUT   = "tableau_views_owners.csv"
HEADLESS = False                         # keep False for SSO flows
GRID_APPEAR_TIMEOUT_SEC = 180            # time to allow for SSO/login before giving up
# ====================================================

def open_driver():
    opts = Options()
    if HEADLESS:
        opts.add_argument("--headless=new")
    opts.add_argument("--start-maximized")
    opts.add_argument("--disable-gpu")
    opts.add_argument("--window-size=1600,1000")
    # Add these for better performance
    opts.add_argument("--disable-blink-features=AutomationControlled")
    opts.add_argument("--disable-extensions")
    return webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=opts)

def goto_all_views(driver):
    candidates = [
        f"{SERVER}/#/site/{SITE_ID}/explore?view=views",
        f"{SERVER}/#/site/{SITE_ID}/explore?contentType=views",
        f"{SERVER}/#/site/{SITE_ID}/explore?type=views",
        f"{SERVER}/#/site/{SITE_ID}/explore",
    ]
    # Try each candidate until grid shows (gives time for SSO)
    end_by = time.time() + GRID_APPEAR_TIMEOUT_SEC
    tried = 0
    while time.time() < end_by:
        url = candidates[tried % len(candidates)]
        driver.get(url)
        try:
            WebDriverWait(driver, 12).until(
                EC.any_of(
                    EC.presence_of_element_located((By.CSS_SELECTOR, '[role="grid"]')),
                    EC.presence_of_element_located((By.CSS_SELECTOR, '[role="row"]'))
                )
            )
            return
        except Exception:
            tried += 1
            time.sleep(2)
    raise RuntimeError("Timed out waiting for Explore grid (SSO/login not completed?).")

def ensure_all_views_mode(driver):
    """Ensure we're viewing 'All Views' and not just workbooks or projects"""
    try:
        # Look for the dropdown that shows "All Views" in your screenshot
        dropdown_selectors = [
            "button[aria-label*='Type']",
            "button[title*='Type']",
            "div[role='button']:has-text('All Views')",
            "button:has-text('All Views')",
            # Generic dropdown button selectors
            "button[class*='dropdown']",
            "div[class*='dropdown'][role='button']"
        ]
        
        for selector in dropdown_selectors:
            try:
                elements = driver.find_elements(By.CSS_SELECTOR, selector)
                for elem in elements:
                    text = elem.text.strip()
                    if any(keyword in text.lower() for keyword in ['type', 'all views', 'views']):
                        driver.execute_script("arguments[0].click();", elem)
                        time.sleep(0.5)
                        
                        # Look for "All Views" option
                        all_views_options = driver.find_elements(
                            By.XPATH, 
                            "//*[contains(text(), 'All Views') or contains(text(), 'Views')]"
                        )
                        for option in all_views_options:
                            if 'all views' in option.text.lower():
                                driver.execute_script("arguments[0].click();", option)
                                time.sleep(1)
                                return
                        break
            except Exception:
                continue
    except Exception as e:
        print(f"Warning: Could not ensure All Views mode: {e}")

def set_rows_per_page_max(driver):
    """Set to maximum rows per page to reduce pagination"""
    try:
        # Look for rows per page selector
        selectors = [
            "select[aria-label*='rows per page' i]",
            "select[title*='rows per page' i]",
            "select[aria-label*='page size' i]",
            "select[class*='page-size']",
            "select[class*='rows-per-page']"
        ]
        
        for selector in selectors:
            elements = driver.find_elements(By.CSS_SELECTOR, selector)
            for sel_elem in elements:
                try:
                    select = Select(sel_elem)
                    # Find the largest numeric option
                    max_option = None
                    max_value = 0
                    
                    for option in select.options:
                        text = option.text.strip()
                        # Extract numeric value
                        numeric_part = ''.join(filter(str.isdigit, text))
                        if numeric_part:
                            value = int(numeric_part)
                            if value > max_value:
                                max_value = value
                                max_option = option
                    
                    if max_option:
                        select.select_by_visible_text(max_option.text)
                        time.sleep(2)  # Wait for page to reload
                        print(f"Set page size to: {max_option.text}")
                        return True
                except Exception:
                    continue
                    
    except Exception as e:
        print(f"Could not set max rows per page: {e}")
    return False

def locate_header_indexes(driver):
    """Find the column indexes for Name and Owner"""
    headers = driver.find_elements(By.CSS_SELECTOR, '[role="columnheader"]')
    name_idx, owner_idx = None, None
    
    print("Available headers:")
    for i, h in enumerate(headers):
        header_text = h.text.strip()
        aria_label = (h.get_attribute("aria-label") or "").strip()
        print(f"  {i}: Text='{header_text}' | Aria-label='{aria_label}'")
        
        # Look for Name column
        if header_text.lower() == "name":
            name_idx = i
        # Look for Owner column (should be the rightmost column based on your screenshot)
        elif header_text.lower() == "owner":
            owner_idx = i
        # Also check aria-label for hidden text
        elif "name" in aria_label.lower() and name_idx is None:
            name_idx = i
        elif "owner" in aria_label.lower() and owner_idx is None:
            owner_idx = i
    
    # Based on your screenshot, let's apply some logic:
    # Name should be around index 1 (after Type column)
    # Owner should be the last column
    if name_idx is None:
        # Look for a column that might be Name based on position
        for i, h in enumerate(headers):
            if i > 0 and i < 3:  # Name is usually in position 1 or 2
                header_text = h.text.strip()
                if header_text and header_text.lower() not in ['type', 'actions']:
                    name_idx = i
                    print(f"Guessing Name column at index {i} based on position")
                    break
        if name_idx is None:
            name_idx = 1  # Conservative guess
    
    if owner_idx is None:
        # Owner is typically the last column in your interface
        owner_idx = len(headers) - 1
        print(f"Owner column likely at last position: index {owner_idx}")
    
    print(f"\nFinal selection - Name index: {name_idx}, Owner index: {owner_idx}")
    if name_idx < len(headers):
        print(f"Name column header: '{headers[name_idx].text}'")
    if owner_idx < len(headers):
        print(f"Owner column header: '{headers[owner_idx].text}'")
    
    return name_idx, owner_idx

def extract_rows_on_screen(driver, name_idx, owner_idx):
    """Extract all visible rows from the current screen"""
    data = []
    try:
        rows = driver.find_elements(By.CSS_SELECTOR, '[role="row"]')
        print(f"Found {len(rows)} rows on screen")
        
        for row_num, row in enumerate(rows):
            cells = row.find_elements(By.CSS_SELECTOR, '[role="gridcell"], [role="columnheader"]')
            
            # Skip if not enough cells
            if len(cells) <= max(name_idx, owner_idx):
                continue
                
            # Get the cell contents
            name_cell = cells[name_idx] if name_idx < len(cells) else None
            owner_cell = cells[owner_idx] if owner_idx < len(cells) else None
            
            if not name_cell or not owner_cell:
                continue
                
            view_name = name_cell.text.strip()
            owner_name = owner_cell.text.strip()
            
            # Debug: Print first few rows to verify we're getting the right data
            if row_num < 5:
                print(f"Row {row_num}: Name='{view_name}' | Owner='{owner_name}'")
            
            # Skip header rows and empty rows
            if (not view_name or not owner_name or 
                view_name.lower() in ['name', 'type', ''] or
                owner_name.lower() in ['owner', 'type', '']):
                continue
            
            # Try to get the URL from the name cell
            view_url = ""
            try:
                link = name_cell.find_element(By.CSS_SELECTOR, "a")
                view_url = link.get_attribute("href") or ""
            except Exception:
                # If no direct link, try to construct URL from other attributes
                try:
                    # Sometimes the URL is in parent elements or data attributes
                    possible_links = row.find_elements(By.CSS_SELECTOR, "a")
                    for link in possible_links:
                        href = link.get_attribute("href") or ""
                        if "/views/" in href or "workbooks/" in href:
                            view_url = href
                            break
                except Exception:
                    pass
            
            data.append((view_name, owner_name, view_url))
    
    except Exception as e:
        print(f"Error extracting rows: {e}")
        import traceback
        traceback.print_exc()
    
    print(f"Extracted {len(data)} valid records from current screen")
    return data

def scroll_and_wait(driver, grid_element):
    """Scroll down and wait for new content to load"""
    try:
        # Multiple scrolling strategies
        current_height = driver.execute_script("return arguments[0].scrollHeight;", grid_element)
        
        # Method 1: Scroll the grid container
        driver.execute_script("arguments[0].scrollTop = arguments[0].scrollHeight;", grid_element)
        time.sleep(1)
        
        # Method 2: Use Page Down key
        actions = ActionChains(driver)
        actions.send_keys(Keys.PAGE_DOWN).perform()
        time.sleep(0.5)
        
        # Method 3: Scroll the whole page
        driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")
        time.sleep(0.5)
        
        # Wait for potential new content
        for _ in range(5):  # Wait up to 2.5 seconds for new content
            new_height = driver.execute_script("return arguments[0].scrollHeight;", grid_element)
            if new_height > current_height:
                return True
            time.sleep(0.5)
            
    except Exception as e:
        print(f"Error during scroll: {e}")
    
    return False

def check_for_pagination_controls(driver):
    """Look for and click pagination controls"""
    # Common pagination button texts and selectors
    pagination_selectors = [
        "//button[contains(text(), 'Next')]",
        "//button[contains(text(), 'Load more')]",
        "//button[contains(text(), 'Show more')]",
        "//a[contains(text(), 'Next')]",
        "//button[contains(@aria-label, 'Next')]",
        "//button[contains(@title, 'Next')]",
        "button[class*='next']:not([disabled])",
        "button[class*='more']:not([disabled])",
        "a[class*='next']"
    ]
    
    for selector in pagination_selectors:
        try:
            if selector.startswith("//"):
                elements = driver.find_elements(By.XPATH, selector)
            else:
                elements = driver.find_elements(By.CSS_SELECTOR, selector)
                
            for elem in elements:
                if elem.is_displayed() and elem.is_enabled():
                    try:
                        driver.execute_script("arguments[0].click();", elem)
                        print(f"Clicked pagination control: {elem.text}")
                        time.sleep(2)
                        return True
                    except Exception:
                        continue
        except Exception:
            continue
    
    return False

def harvest_all_views(driver, name_idx, owner_idx, max_iterations=50):
    """Harvest all views with improved pagination handling"""
    all_records = set()
    
    try:
        grid = driver.find_element(By.CSS_SELECTOR, '[role="grid"]')
    except Exception:
        print("Could not find grid element")
        return []
    
    iterations_without_new_data = 0
    iteration = 0
    
    print("Starting to harvest views...")
    
    while iteration < max_iterations:
        iteration += 1
        print(f"\nIteration {iteration}")
        
        # Extract current visible data
        current_records = extract_rows_on_screen(driver, name_idx, owner_idx)
        initial_count = len(all_records)
        
        for record in current_records:
            all_records.add(record)
        
        new_records_found = len(all_records) - initial_count
        print(f"Found {new_records_found} new records (total: {len(all_records)})")
        
        if new_records_found > 0:
            iterations_without_new_data = 0
        else:
            iterations_without_new_data += 1
        
        # If no new data for several iterations, try harder methods
        if iterations_without_new_data >= 3:
            print("No new data found, trying pagination controls...")
            if check_for_pagination_controls(driver):
                iterations_without_new_data = 0
                continue
        
        # Stop if no new data for too long
        if iterations_without_new_data >= 5:
            print("No new data found for 5 iterations, stopping...")
            break
        
        # Scroll and wait for new content
        scroll_and_wait(driver, grid)
    
    print(f"\nHarvesting complete. Found {len(all_records)} total records.")
    return list(all_records)

def main():
    driver = open_driver()
    try:
        print("Navigating to Tableau...")
        goto_all_views(driver)
        
        print("Ensuring All Views mode...")
        ensure_all_views_mode(driver)
        
        print("Setting maximum rows per page...")
        set_rows_per_page_max(driver)
        
        # Wait for the grid to be ready
        print("Waiting for grid to load...")
        WebDriverWait(driver, 45).until(
            EC.presence_of_element_located((By.CSS_SELECTOR, '[role="row"]'))
        )
        
        print("Locating column headers...")
        name_idx, owner_idx = locate_header_indexes(driver)
        
        print("Harvesting all views...")
        records = harvest_all_views(driver, name_idx, owner_idx)
        
        if not records:
            print("No records found. Please check the column indexes and selectors.")
            return
        
        # Sort and save
        df = pd.DataFrame(
            sorted(records, key=lambda x: (x[1].lower(), x[0].lower())),
            columns=["view_name", "owner_name", "view_url"]
        )
        
        df.to_csv(OUTPUT, index=False)
        print(f"\n✅ Successfully saved {len(df):,} rows to {OUTPUT}")
        
        # Show sample of results
        print("\nSample of extracted data:")
        print(df.head(10).to_string(index=False))
        
        # Show owner distribution
        print("\nTop 10 view owners by count:")
        owner_counts = df['owner_name'].value_counts().head(10)
        for owner, count in owner_counts.items():
            print(f"  {owner}: {count} views")
        
    except Exception as e:
        print(f"Error during execution: {e}")
        import traceback
        traceback.print_exc()
    finally:
        if not HEADLESS:
            input("Press Enter to close the browser...")
        try:
            driver.quit()
        except Exception:
            pass

if __name__ == "__main__":
    main()
