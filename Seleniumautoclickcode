
# tableau_views_owners_autoscroll.py
# Scrapes Tableau Explore ▸ All Views (View Name, Owner, URL) with full auto-scroll (no API, no ENTER).

import time
import pandas as pd
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait, Select
from selenium.webdriver.support import expected_conditions as EC
from webdriver_manager.chrome import ChromeDriverManager
from selenium.webdriver.chrome.service import Service as ChromeService

# ==================== EDIT THESE ====================
SERVER   = "https://mytableau.cvs.com"   # no trailing '/#/'
SITE_ID  = "RX_OPS"                      # must match /site/<value>/ in URLs
OUTPUT   = "tableau_views_owners.csv"
HEADLESS = False                         # keep False for SSO flows
GRID_APPEAR_TIMEOUT_SEC = 180            # time to allow for SSO/login before giving up
# ====================================================

def open_driver():
    opts = Options()
    if HEADLESS:
        opts.add_argument("--headless=new")
    opts.add_argument("--start-maximized")
    opts.add_argument("--disable-gpu")
    opts.add_argument("--window-size=1600,1000")
    return webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=opts)

def goto_all_views(driver):
    candidates = [
        f"{SERVER}/#/site/{SITE_ID}/explore?view=views",
        f"{SERVER}/#/site/{SITE_ID}/explore?contentType=views",
        f"{SERVER}/#/site/{SITE_ID}/explore?type=views",
        f"{SERVER}/#/site/{SITE_ID}/explore",
    ]
    # Try each candidate until grid shows (gives time for SSO)
    end_by = time.time() + GRID_APPEAR_TIMEOUT_SEC
    tried = 0
    while time.time() < end_by:
        url = candidates[tried % len(candidates)]
        driver.get(url)
        try:
            WebDriverWait(driver, 12).until(
                EC.any_of(
                    EC.presence_of_element_located((By.CSS_SELECTOR, '[role="grid"]')),
                    EC.presence_of_element_located((By.CSS_SELECTOR, '[role="row"]'))
                )
            )
            return
        except Exception:
            tried += 1
            time.sleep(2)
    raise RuntimeError("Timed out waiting for Explore grid (SSO/login not completed?).")

def ensure_all_views_mode(driver):
    # If a type dropdown exists, switch to "All Views"
    try:
        # open any nearby dropdowns and pick 'All Views'
        for btn in driver.find_elements(By.CSS_SELECTOR, "button, div[role='button']"):
            txt = (btn.text or "").strip().lower()
            if not txt:
                continue
            if any(k in txt for k in ["views", "workbooks", "projects", "all views", "top-level projects"]):
                try:
                    btn.click(); time.sleep(0.4)
                    items = driver.find_elements(
                        By.XPATH,
                        "//*[self::div or self::span or self::a]"
                        "[contains(translate(text(),'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz'),'all views')]"
                    )
                    if items:
                        items[0].click(); time.sleep(0.6)
                        break
                except Exception:
                    pass
    except Exception:
        pass

def set_rows_per_page_max(driver):
    """If a rows-per-page selector exists, choose the largest option."""
    try:
        # Common selectors Tableau uses for page-size controls
        sel_elems = []
        sel_elems += driver.find_elements(By.XPATH, "//select[contains(translate(@aria-label,'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz'),'rows per page')]")
        sel_elems += driver.find_elements(By.XPATH, "//select[contains(translate(@title,'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz'),'rows per page')]")
        for sel in sel_elems:
            s = Select(sel)
            # choose max numeric option
            best_idx, best_val = 0, 0
            for i, opt in enumerate(s.options):
                txt = (opt.text or "").strip()
                try:
                    val = int(''.join(ch for ch in txt if ch.isdigit()))
                except Exception:
                    val = 0
                if val >= best_val:
                    best_idx, best_val = i, val
            s.select_by_index(best_idx)
            time.sleep(1.0)
            return True
    except Exception:
        pass
    return False

def locate_header_indexes(driver):
    headers = driver.find_elements(By.CSS_SELECTOR, '[role="columnheader"]')
    name_idx, owner_idx = None, None
    for i, h in enumerate(headers):
        label = (h.text or "").strip().lower()
        if label == "name":  name_idx = i
        if label == "owner": owner_idx = i
    if name_idx is None: name_idx = 0
    if owner_idx is None:
        for i, h in enumerate(headers):
            aria = (h.get_attribute("aria-label") or "").lower()
            if "owner" in aria:
                owner_idx = i; break
    if owner_idx is None: owner_idx = 2
    return name_idx, owner_idx

def get_grid(driver):
    return driver.find_element(By.CSS_SELECTOR, '[role="grid"]')

def click_load_more_if_any(driver) -> bool:
    """Click 'Load more' / 'Show more' / 'Next' style buttons if visible."""
    candidates = driver.find_elements(
        By.XPATH,
        "//button[not(@disabled) and ("
        "contains(translate(.,'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz'),'load more') or "
        "contains(translate(.,'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz'),'show more') or "
        "contains(translate(@aria-label,'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz'),'next') or "
        "contains(translate(@title,'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz'),'next'))]"
    )
    for b in candidates:
        if b.is_displayed():
            try:
                b.click(); time.sleep(1.2)
                return True
            except Exception:
                pass
    return False

def extract_rows_on_screen(driver, name_idx, owner_idx):
    data = []
    rows = driver.find_elements(By.CSS_SELECTOR, '[role="row"]')
    for r in rows:
        cells = r.find_elements(By.CSS_SELECTOR, '[role="gridcell"]')
        if len(cells) <= max(name_idx, owner_idx): continue
        vcell, ocell = cells[name_idx], cells[owner_idx]
        vname = (vcell.text or "").strip()
        owner = (ocell.text or "").strip()
        vurl  = ""
        try:
            a = vcell.find_element(By.CSS_SELECTOR, "a")
            vurl = a.get_attribute("href") or ""
        except Exception:
            pass
        if vname and owner and vname.lower() != "name":
            data.append((vname, owner, vurl))
    return data

def harvest_all(driver, name_idx, owner_idx, max_idle=4):
    grid = get_grid(driver)
    seen = set()
    idle = 0
    last = 0

    def scroll_to_bottom():
        driver.execute_script("arguments[0].scrollTop = arguments[0].scrollHeight;", grid)

    # try to maximize rows per page first
    set_rows_per_page_max(driver)

    while True:
        # collect visible chunk
        for rec in extract_rows_on_screen(driver, name_idx, owner_idx): seen.add(rec)

        # try pager, else scroll the grid container
        if not click_load_more_if_any(driver):
            scroll_to_bottom()
        time.sleep(1.0)

        # collect again after movement
        for rec in extract_rows_on_screen(driver, name_idx, owner_idx): seen.add(rec)

        curr = len(seen)
        if curr == last: idle += 1
        else: idle = 0
        last = curr

        if idle >= max_idle: break

    return list(seen)

def main():
    driver = open_driver()
    try:
        goto_all_views(driver)
        ensure_all_views_mode(driver)

        # Wait for any grid rows (gives time for the page to load content)
        WebDriverWait(driver, 45).until(
            EC.presence_of_element_located((By.CSS_SELECTOR, '[role="row"]'))
        )

        name_idx, owner_idx = locate_header_indexes(driver)
        records = harvest_all(driver, name_idx, owner_idx)

        df = pd.DataFrame(sorted(set(records), key=lambda x: (x[1].lower(), x[0].lower())),
                          columns=["view_name", "owner_name", "view_url"])
        df.to_csv(OUTPUT, index=False)
        print(f"✅ Saved {len(df):,} rows to {OUTPUT}")
    finally:
        try:
            if HEADLESS: driver.quit()
        except Exception:
            pass

if __name__ == "__main__":
    main()
