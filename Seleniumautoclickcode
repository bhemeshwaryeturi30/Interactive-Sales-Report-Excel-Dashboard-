
def get_view_details_from_url(driver, view_url, retries=2):
    """Try to get detailed view information by visiting the view URL"""
    if not view_url:
        return None, None
    
    original_url = driver.current_url
    try:
        driver.get(view_url)
        time.sleep(3)  # Wait for page to load
        
        # Look for view details/metadata
        owner_selectors = [
            "[data-test-id*='owner']",
            "[class*='owner']",
            "[class*='author']",
            ".metadata .owner",
            ".view-info .owner",
            ".workbook-info .owner"
        ]
        
        view_owner = None
        workbook_owner = None
        
        for selector in owner_selectors:
            try:
                elements = driver.find_elements(By.CSS_SELECTOR, selector)
                for elem in elements:
                    text = elem.text.strip()
                    if text and len(text) > 0:
                        # Try to determine if this is view owner or workbook owner
                        if 'workbook' in elem.get_attribute('class').lower():
                            workbook_owner = text
                        else:
                            view_owner = text
                        break
                if view_owner:
                    break
            except:
                continue
        
        return view_owner, workbook_owner
        
    except Exception as e:
        print(f"Error getting view details: {e}")
        return None, None
    finally:
        try:
            driver.get(original_url)
            time.sleep(2)
        except:
            pass

def extract_rows_on_screen(driver, name_idx, owner_idx, get_detailed_owner=False):
    """Extract all visible rows from the current screen"""
    data = []
    try:
        rows = driver.find_elements(By.CSS_SELECTOR, '[role="row"]')
        for row in rows:
            cells = row.find_elements(By# tableau_views_owners_autoscroll_enhanced.py
# Enhanced scraper for Tableau Explore ▸ All Views with improved pagination handling

import time
import pandas as pd
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait, Select
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.action_chains import ActionChains
from webdriver_manager.chrome import ChromeDriverManager
from selenium.webdriver.chrome.service import Service as ChromeService

# ==================== EDIT THESE ====================
SERVER   = "https://mytableau.cvs.com"   # no trailing '/#/'
SITE_ID  = "RX_OPS"                      # must match /site/<value>/ in URLs
OUTPUT   = "tableau_views_owners.csv"
HEADLESS = False                         # keep False for SSO flows
GRID_APPEAR_TIMEOUT_SEC = 180            # time to allow for SSO/login before giving up
# ====================================================

def open_driver():
    opts = Options()
    if HEADLESS:
        opts.add_argument("--headless=new")
    opts.add_argument("--start-maximized")
    opts.add_argument("--disable-gpu")
    opts.add_argument("--window-size=1600,1000")
    # Add these for better performance
    opts.add_argument("--disable-blink-features=AutomationControlled")
    opts.add_argument("--disable-extensions")
    return webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=opts)

def goto_all_views(driver):
    candidates = [
        f"{SERVER}/#/site/{SITE_ID}/explore?view=views",
        f"{SERVER}/#/site/{SITE_ID}/explore?contentType=views",
        f"{SERVER}/#/site/{SITE_ID}/explore?type=views",
        f"{SERVER}/#/site/{SITE_ID}/explore",
    ]
    # Try each candidate until grid shows (gives time for SSO)
    end_by = time.time() + GRID_APPEAR_TIMEOUT_SEC
    tried = 0
    while time.time() < end_by:
        url = candidates[tried % len(candidates)]
        driver.get(url)
        try:
            WebDriverWait(driver, 12).until(
                EC.any_of(
                    EC.presence_of_element_located((By.CSS_SELECTOR, '[role="grid"]')),
                    EC.presence_of_element_located((By.CSS_SELECTOR, '[role="row"]'))
                )
            )
            return
        except Exception:
            tried += 1
            time.sleep(2)
    raise RuntimeError("Timed out waiting for Explore grid (SSO/login not completed?).")

def ensure_all_views_mode(driver):
    """Ensure we're viewing 'All Views' and not just workbooks or projects"""
    try:
        # Look for the dropdown that shows "All Views" in your screenshot
        dropdown_selectors = [
            "button[aria-label*='Type']",
            "button[title*='Type']",
            "div[role='button']:has-text('All Views')",
            "button:has-text('All Views')",
            # Generic dropdown button selectors
            "button[class*='dropdown']",
            "div[class*='dropdown'][role='button']"
        ]
        
        for selector in dropdown_selectors:
            try:
                elements = driver.find_elements(By.CSS_SELECTOR, selector)
                for elem in elements:
                    text = elem.text.strip()
                    if any(keyword in text.lower() for keyword in ['type', 'all views', 'views']):
                        driver.execute_script("arguments[0].click();", elem)
                        time.sleep(0.5)
                        
                        # Look for "All Views" option
                        all_views_options = driver.find_elements(
                            By.XPATH, 
                            "//*[contains(text(), 'All Views') or contains(text(), 'Views')]"
                        )
                        for option in all_views_options:
                            if 'all views' in option.text.lower():
                                driver.execute_script("arguments[0].click();", option)
                                time.sleep(1)
                                return
                        break
            except Exception:
                continue
    except Exception as e:
        print(f"Warning: Could not ensure All Views mode: {e}")

def set_rows_per_page_max(driver):
    """Set to maximum rows per page to reduce pagination"""
    try:
        # Look for rows per page selector
        selectors = [
            "select[aria-label*='rows per page' i]",
            "select[title*='rows per page' i]",
            "select[aria-label*='page size' i]",
            "select[class*='page-size']",
            "select[class*='rows-per-page']"
        ]
        
        for selector in selectors:
            elements = driver.find_elements(By.CSS_SELECTOR, selector)
            for sel_elem in elements:
                try:
                    select = Select(sel_elem)
                    # Find the largest numeric option
                    max_option = None
                    max_value = 0
                    
                    for option in select.options:
                        text = option.text.strip()
                        # Extract numeric value
                        numeric_part = ''.join(filter(str.isdigit, text))
                        if numeric_part:
                            value = int(numeric_part)
                            if value > max_value:
                                max_value = value
                                max_option = option
                    
                    if max_option:
                        select.select_by_visible_text(max_option.text)
                        time.sleep(2)  # Wait for page to reload
                        print(f"Set page size to: {max_option.text}")
                        return True
                except Exception as e:
                    continue
                    
    except Exception as e:
        print(f"Could not set max rows per page: {e}")
    return False

def locate_header_indexes(driver):
    """Find the column indexes for Name and Owner"""
    headers = driver.find_elements(By.CSS_SELECTOR, '[role="columnheader"]')
    name_idx, owner_idx = None, None
    
    print("Available headers:")
    for i, h in enumerate(headers):
        header_text = h.text.strip()
        print(f"  {i}: '{header_text}'")
        
        if header_text.lower() == "name":
            name_idx = i
        elif header_text.lower() == "owner":
            owner_idx = i
    
    # Fallback logic
    if name_idx is None:
        name_idx = 0  # Usually first column
    if owner_idx is None:
        # Look for owner in aria-label or try common positions
        for i, h in enumerate(headers):
            aria_label = (h.get_attribute("aria-label") or "").lower()
            if "owner" in aria_label:
                owner_idx = i
                break
        if owner_idx is None:
            owner_idx = len(headers) - 1  # Often last column
    
    print(f"Using Name index: {name_idx}, Owner index: {owner_idx}")
    return name_idx, owner_idx

def extract_rows_on_screen(driver, name_idx, owner_idx):
    """Extract all visible rows from the current screen"""
    data = []
    try:
        rows = driver.find_elements(By.CSS_SELECTOR, '[role="row"]')
        for row in rows:
            cells = row.find_elements(By.CSS_SELECTOR, '[role="gridcell"], [role="columnheader"]')
            
            # Skip if not enough cells or if this is a header row
            if len(cells) <= max(name_idx, owner_idx):
                continue
                
            name_cell = cells[name_idx] if name_idx < len(cells) else None
            owner_cell = cells[owner_idx] if owner_idx < len(cells) else None
            
            if not name_cell or not owner_cell:
                continue
                
            view_name = name_cell.text.strip()
            owner_name = owner_cell.text.strip()
            
            # Skip header rows and empty rows
            if not view_name or not owner_name or view_name.lower() in ['name', 'type']:
                continue
            
            # Try to get the URL from the name cell
            view_url = ""
            try:
                link = name_cell.find_element(By.CSS_SELECTOR, "a")
                view_url = link.get_attribute("href") or ""
            except Exception:
                pass
            
            data.append((view_name, owner_name, view_url))
    
    except Exception as e:
        print(f"Error extracting rows: {e}")
    
    return data

def scroll_and_wait(driver, grid_element):
    """Scroll down and wait for new content to load"""
    try:
        # Multiple scrolling strategies
        current_height = driver.execute_script("return arguments[0].scrollHeight;", grid_element)
        
        # Method 1: Scroll the grid container
        driver.execute_script("arguments[0].scrollTop = arguments[0].scrollHeight;", grid_element)
        time.sleep(1)
        
        # Method 2: Use Page Down key
        actions = ActionChains(driver)
        actions.send_keys(Keys.PAGE_DOWN).perform()
        time.sleep(0.5)
        
        # Method 3: Scroll the whole page
        driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")
        time.sleep(0.5)
        
        # Wait for potential new content
        for _ in range(5):  # Wait up to 2.5 seconds for new content
            new_height = driver.execute_script("return arguments[0].scrollHeight;", grid_element)
            if new_height > current_height:
                return True
            time.sleep(0.5)
            
    except Exception as e:
        print(f"Error during scroll: {e}")
    
    return False

def check_for_pagination_controls(driver):
    """Look for and click pagination controls"""
    # Common pagination button texts and selectors
    pagination_selectors = [
        "//button[contains(text(), 'Next')]",
        "//button[contains(text(), 'Load more')]",
        "//button[contains(text(), 'Show more')]",
        "//a[contains(text(), 'Next')]",
        "//button[contains(@aria-label, 'Next')]",
        "//button[contains(@title, 'Next')]",
        "button[class*='next']:not([disabled])",
        "button[class*='more']:not([disabled])",
        "a[class*='next']"
    ]
    
    for selector in pagination_selectors:
        try:
            if selector.startswith("//"):
                elements = driver.find_elements(By.XPATH, selector)
            else:
                elements = driver.find_elements(By.CSS_SELECTOR, selector)
                
            for elem in elements:
                if elem.is_displayed() and elem.is_enabled():
                    try:
                        driver.execute_script("arguments[0].click();", elem)
                        print(f"Clicked pagination control: {elem.text}")
                        time.sleep(2)
                        return True
                    except Exception:
                        continue
        except Exception:
            continue
    
    return False

def harvest_all_views(driver, name_idx, owner_idx, max_iterations=50):
    """Harvest all views with improved pagination handling"""
    all_records = set()
    
    try:
        grid = driver.find_element(By.CSS_SELECTOR, '[role="grid"]')
    except Exception:
        print("Could not find grid element")
        return []
    
    iterations_without_new_data = 0
    iteration = 0
    
    print("Starting to harvest views...")
    
    while iteration < max_iterations:
        iteration += 1
        print(f"\nIteration {iteration}")
        
        # Extract current visible data
        current_records = extract_rows_on_screen(driver, name_idx, owner_idx)
        initial_count = len(all_records)
        
        for record in current_records:
            all_records.add(record)
        
        new_records_found = len(all_records) - initial_count
        print(f"Found {new_records_found} new records (total: {len(all_records)})")
        
        if new_records_found > 0:
            iterations_without_new_data = 0
        else:
            iterations_without_new_data += 1
        
        # If no new data for several iterations, try harder methods
        if iterations_without_new_data >= 3:
            print("No new data found, trying pagination controls...")
            if check_for_pagination_controls(driver):
                iterations_without_new_data = 0
                continue
        
        # Stop if no new data for too long
        if iterations_without_new_data >= 5:
            print("No new data found for 5 iterations, stopping...")
            break
        
        # Scroll and wait for new content
        scroll_and_wait(driver, grid)
    
    print(f"\nHarvesting complete. Found {len(all_records)} total records.")
    return list(all_records)

def main():
    driver = open_driver()
    try:
        print("Navigating to Tableau...")
        goto_all_views(driver)
        
        print("Ensuring All Views mode...")
        ensure_all_views_mode(driver)
        
        print("Setting maximum rows per page...")
        set_rows_per_page_max(driver)
        
        # Wait for the grid to be ready
        print("Waiting for grid to load...")
        WebDriverWait(driver, 45).until(
            EC.presence_of_element_located((By.CSS_SELECTOR, '[role="row"]'))
        )
        
        print("Locating column headers...")
        name_idx, owner_idx = locate_header_indexes(driver)
        
        print("Harvesting all views...")
        records = harvest_all_views(driver, name_idx, owner_idx)
        
        if not records:
            print("No records found. Please check the column indexes and selectors.")
            return
        
        # Sort and save
        df = pd.DataFrame(
            sorted(records, key=lambda x: (x[1].lower(), x[0].lower())),
            columns=["view_name", "owner_name", "view_url"]
        )
        
        df.to_csv(OUTPUT, index=False)
        print(f"\n✅ Successfully saved {len(df):,} rows to {OUTPUT}")
        
        # Show sample of results
        print("\nSample of extracted data:")
        print(df.head(10).to_string(index=False))
        
    except Exception as e:
        print(f"Error during execution: {e}")
        import traceback
        traceback.print_exc()
    finally:
        if not HEADLESS:
            input("Press Enter to close the browser...")
        try:
            driver.quit()
        except Exception:
            pass

if __name__ == "__main__":
    main()
