# tableau_views_owners_scrape.py
# Scrapes Tableau Explore ▸ All Views WITHOUT using the REST API.
# Outputs: view_name, owner_name, view_url

import time
import pandas as pd
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from webdriver_manager.chrome import ChromeDriverManager
from selenium.webdriver.chrome.service import Service as ChromeService
from selenium.webdriver.chrome.options import Options

# ==================== EDIT THESE ====================
SERVER   = "https://mytableau.cvs.com"   # no trailing '/#/'
SITE_ID  = "RX_OPS"                      # must match /site/<value>/ in URLs
OUTPUT   = "tableau_views_owners.csv"
HEADLESS = False                         # use False for SSO; True for silent run
# ====================================================

def open_driver():
    opts = Options()
    if HEADLESS:
        opts.add_argument("--headless=new")
    opts.add_argument("--start-maximized")
    opts.add_argument("--disable-gpu")
    opts.add_argument("--window-size=1600,1000")
    # fewer automation flags reduces SSO friction
    return webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=opts)

def goto_all_views(driver):
    # Try a few URL variants Tableau uses for Explore
    candidates = [
        f"{SERVER}/#/site/{SITE_ID}/explore?view=views",
        f"{SERVER}/#/site/{SITE_ID}/explore?contentType=views",
        f"{SERVER}/#/site/{SITE_ID}/explore?type=views",
        f"{SERVER}/#/site/{SITE_ID}/explore"
    ]
    for url in candidates:
        driver.get(url)
        try:
            WebDriverWait(driver, 25).until(
                EC.any_of(
                    EC.presence_of_element_located((By.CSS_SELECTOR, '[role="grid"]')),
                    EC.presence_of_element_located((By.CSS_SELECTOR, '[role="row"]'))
                )
            )
            return
        except Exception:
            pass
    raise RuntimeError("Could not open Explore page / grid not found.")

def ensure_all_views_mode(driver):
    """If a type dropdown is present, switch to 'All Views'."""
    try:
        # Try to open dropdown near the Explore type selector
        buttons = driver.find_elements(By.CSS_SELECTOR, "button, div[role='button']")
        for b in buttons:
            txt = (b.text or "").strip().lower()
            if not txt:
                continue
            if any(k in txt for k in ["views", "projects", "workbooks", "all views", "top-level projects"]):
                try:
                    b.click()
                    time.sleep(0.5)
                    menu_items = driver.find_elements(
                        By.XPATH,
                        "//*[self::div or self::span or self::a]"
                        "[contains(translate(text(),'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz'),'all views')]"
                    )
                    if menu_items:
                        menu_items[0].click()
                        time.sleep(1.0)
                        break
                except Exception:
                    pass
    except Exception:
        pass

def locate_header_indexes(driver):
    """Return (name_idx, owner_idx) by reading table headers; use heuristics if missing."""
    headers = driver.find_elements(By.CSS_SELECTOR, '[role="columnheader"]')
    name_idx, owner_idx = None, None
    for i, h in enumerate(headers):
        label = (h.text or "").strip().lower()
        if label == "name":
            name_idx = i
        if label == "owner":
            owner_idx = i
    if name_idx is None:
        name_idx = 0
    if owner_idx is None:
        # Try aria-labels
        for i, h in enumerate(headers):
            aria = (h.get_attribute("aria-label") or "").lower()
            if "owner" in aria:
                owner_idx = i
                break
    if owner_idx is None:
        owner_idx = 2  # common default order: Name, Type, Owner
    return name_idx, owner_idx

def get_grid(driver):
    """The virtualized grid container that actually scrolls."""
    return driver.find_element(By.CSS_SELECTOR, '[role="grid"]')

def click_load_more_if_any(driver) -> bool:
    """Click 'Load more' / 'Show more' / 'Next' buttons if visible."""
    candidates = driver.find_elements(
        By.XPATH,
        "//button[not(@disabled) and ("
        "contains(translate(.,'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz'),'load more') or "
        "contains(translate(.,'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz'),'show more') or "
        "contains(translate(@aria-label,'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz'),'next') or "
        "contains(translate(@title,'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz'),'next'))]"
    )
    for b in candidates:
        if b.is_displayed():
            try:
                b.click()
                time.sleep(1.2)
                return True
            except Exception:
                pass
    return False

def extract_rows_on_current_screen(driver, name_idx, owner_idx):
    """Parse all rendered rows on the grid (virtualized)."""
    data = []
    rows = driver.find_elements(By.CSS_SELECTOR, '[role="row"]')
    for r in rows:
        cells = r.find_elements(By.CSS_SELECTOR, '[role="gridcell"]')
        if len(cells) <= max(name_idx, owner_idx):
            continue
        view_cell  = cells[name_idx]
        owner_cell = cells[owner_idx]
        view_name = (view_cell.text or "").strip()
        owner     = (owner_cell.text or "").strip()

        # Try to capture URL from anchor inside the name cell
        view_url = ""
        try:
            a = view_cell.find_element(By.CSS_SELECTOR, "a")
            view_url = a.get_attribute("href") or ""
        except Exception:
            pass

        # Skip headers / blanks
        if view_name and owner and view_name.lower() != "name":
            data.append((view_name, owner, view_url))
    return data

def smart_harvest_all_rows(driver, name_idx, owner_idx, max_idle=4):
    """
    Scroll the grid container to bottom repeatedly, and click any pager buttons, until
    the number of unique rows stops increasing for a few consecutive rounds.
    """
    grid = get_grid(driver)
    seen = set()
    idle_rounds = 0
    last_count = 0

    def scroll_to_bottom():
        driver.execute_script("arguments[0].scrollTop = arguments[0].scrollHeight;", grid)

    while True:
        # collect visible chunk
        for rec in extract_rows_on_current_screen(driver, name_idx, owner_idx):
            seen.add(rec)

        # try pager button; otherwise scroll container
        if not click_load_more_if_any(driver):
            scroll_to_bottom()
        time.sleep(1.0)

        # collect again
        for rec in extract_rows_on_current_screen(driver, name_idx, owner_idx):
            seen.add(rec)

        curr = len(seen)
        if curr == last_count:
            idle_rounds += 1
        else:
            idle_rounds = 0
        last_count = curr

        if idle_rounds >= max_idle:
            break

    return list(seen)

def main():
    driver = open_driver()
    try:
        goto_all_views(driver)

        print("\nIf a login page appears, complete SSO now.")
        print("Ensure the Explore dropdown shows **All Views** and the grid is visible.")
        input("Press ENTER here once the grid is visible… ")

        ensure_all_views_mode(driver)

        WebDriverWait(driver, 30).until(
            EC.presence_of_element_located((By.CSS_SELECTOR, '[role=\"row\"]'))
        )

        name_idx, owner_idx = locate_header_indexes(driver)
        all_records = smart_harvest_all_rows(driver, name_idx, owner_idx)

        # Save to CSV
        rows = sorted(list(set(all_records)), key=lambda x: (x[1].lower(), x[0].lower()))
        df = pd.DataFrame(rows, columns=["view_name", "owner_name", "view_url"])
        df.to_csv(OUTPUT, index=False)
        print(f"\n✅ Saved {len(df):,} rows to {OUTPUT}")

    finally:
        try:
            if HEADLESS:
                driver.quit()
        except Exception:
            pass

if __name__ == "__main__":
    main()
